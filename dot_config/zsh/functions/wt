# Capture the initial directory
# INITIAL_DIR=$PWD

# git rev-parse 2> /dev/null
# if [[ $? -eq 0 ]]; then
#   worktree=$(git worktree list | grep -v bare | awk '{print $1,$3}' | fzf --prompt "Switch worktree: " --height 40% --reverse | awk '{print $1}') 
#   if [[ -z $worktree ]]; then
#     cd $INITIAL_DIR || return
#   else
#     cd $worktree || return
#   fi
# else
#   echo "fatal: not in a git repository"
# fi
function log() {
  local log_level=$1
  local msg=$2
  local color
  case $log_level in
    "info") color=32 ;;
    "warn") color=33 ;;
    "error") color=31 ;;
    *) color=0 ;;
  esac
  echo -e "\033[${color}m${log_level}:\033[0m ${msg}"
}

function log_info() {
  log "info" "$1"
}

function log_warn() {
  log "warn" "$1"
}

function log_error() {
  log "error" "$1"
}

INITIAL_DIR=$PWD

function switch_worktree() {
  WORKTREE_LIST=$(git worktree list | grep -v bare | sed 's/\[\(.*\)\]/\1/')
  declare -A worktree_map

  # Create map to track worktree path with branch name
  while read -r line; do
    BRANCH_NAME=$(echo "$line" | awk '{print $3}')
    WORKTREE_PATH=$(echo "$line" | awk '{print $1}')
    worktree_map["$BRANCH_NAME"]=$WORKTREE_PATH
  done <<< "$WORKTREE_LIST"

  CHOSEN_BRANCH=$(git worktree list | grep -v bare | sed 's/\[\(.*\)\]/\1/' | awk '{print "ðŸŒ¿",$3}' | fzf --prompt "Select worktree: " --height 50% --reverse | awk '{print $2}')
  if [[ -z $CHOSEN_BRANCH ]]; then
    log_warn "no worktree selected"
    cd $INITIAL_DIR || return
  else
    WORKTREE_ROOT_PATH=${worktree_map["$CHOSEN_BRANCH"]}
    cd $WORKTREE_ROOT_PATH || return
  fi
}

if git rev-parse 2>/dev/null; then
  if [[ $1 == "base" ]]; then
    BARE_ROOT=$(git worktree list | grep bare | awk '{ print $1 }')
    cd $BARE_ROOT || return
  else
    switch_worktree
  fi
else
  log_error "not a git repository (or any of the parent directories): .git"
  exit 1
fi

# vim: set ft=zsh:
